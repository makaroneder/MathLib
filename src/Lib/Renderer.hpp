#ifndef Renderer_H
#define Renderer_H
#include "Set.hpp"
#include "Line.hpp"
#include "Functions.hpp"
#include <stdint.h>
#include <complex>

struct Renderer {
    /// @brief Current position
    Vector3<num_t> position;
    /// @brief Scale
    num_t pointMultiplier;
    /// @brief Creates a new renderer
    Renderer(void);
    /// @brief Destroys the renderer
    virtual ~Renderer(void);
    /// @brief Calculates width of the renderer window
    /// @return Width of the renderer window
    virtual size_t GetWidth(void) const = 0;
    /// @brief Calculates height of the renderer window
    /// @return Height of the renderer window
    virtual size_t GetHeight(void) const = 0;
    /// @brief Renders pixel
    /// @param p Position of pixel
    /// @param color Color of pixel
    /// @return Status
    virtual bool SetPixel(Vector3<num_t> p, uint32_t color) = 0;
    /// @brief Draws a line
    /// @param line Line to draw
    /// @param color Color of the line
    /// @return Status
    virtual bool DrawLine(Line<num_t> line, uint32_t color) = 0;

    /// @brief Calculates start of the graph
    /// @tparam T Type of number
    /// @return Start of graph
    template <typename T>
    Vector2<T> GetStart(void) const {
        return CreateVector2<T>(-(GetWidth() / 2 / pointMultiplier), -(GetHeight() / 2 / pointMultiplier));
    }
    /// @brief Calculates end of the graph
    /// @tparam T Type of number
    /// @return End of graph
    template <typename T>
    Vector2<T> GetEnd(void) const {
        return CreateVector2<T>(GetWidth() / 2 / pointMultiplier, GetHeight() / 2 / pointMultiplier);
    }
    /// @brief Creates set of every pixel on the screen
    /// @tparam T Type of number
    /// @param axis Axis we are using
    /// @return Set of every pixel on the screen
    template <typename T>
    std::vector<T> CreateRealNumberSet(void) const {
        const bool isFloat = IsFloat<T>();
        const T div = isFloat ? 1 : pointMultiplier;
        const Vector2<T> startArr = GetStart<T>();
        const Vector2<T> endArr = GetEnd<T>();
        return CreateSet<T>(
            std::max<T>(GetVectorAxis(startArr, VectorAxis::X), GetVectorAxis(startArr, VectorAxis::Y)) * div,
            std::max<T>(GetVectorAxis(endArr, VectorAxis::X), GetVectorAxis(endArr, VectorAxis::Y)) * div,
            1 / (isFloat ? pointMultiplier : 1)
        );
    }
    /// @brief Draw x and y axis
    /// @param color Color of the axis
    /// @return Status
    bool DrawAxis(uint32_t color);
    /// @brief Draws function based on its values
    /// @tparam T Type of number
    /// @param values Values generated by function
    /// @param color Color of function
    /// @return Status
    template <typename T>
    bool DrawFunction(std::vector<Line<T>> values, uint32_t color) {
        const T div = IsFloat<T>() ? 1 : pointMultiplier;
        for (const Line<T>& val : values) {
            #ifdef FillGapsInFunctions
            if (!std::isnan(GetVectorAxis(val.start, VectorAxis::X)) && !DrawLine(ConvertLine<T, num_t>(Line<T>(val.start / div, val.end / div)), color)) return false;
            #else
            if (!SetPixel(ConvertMatrix<T, num_t>(val.end) / div, color)) return false;
            #endif
        }
        return true;
    }
    /// @brief y = f(x)
    /// @tparam T Type of number
    /// @param f Function that calculates x or y depending on the 'axis' parameter
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateFunction(std::function<std::complex<T>(T)> f, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        Vector3<T> prev;
        std::vector<Line<T>> ret;
        for (const T& i : inSet) {
            Vector3<T> curr;
            std::complex<T> tmp = f(i);
            if (std::isnan(i) || std::isinf(i) || !IsInsideSet<T>(outSet, tmp.real())) {
                prev = CreateVector3<num_t>(NAN, NAN, NAN);
                continue;
            }
            GetVectorAxis(curr, inAxis) = i;
            GetVectorAxis(curr, realAxis) = tmp.real();
            // TODO: Set z axis to the imaginary part of 'f' output
            GetVectorAxis(curr, imaginaryAxis) = tmp.imag();
            ret.push_back(Line<T>(prev - position, curr - position));
            prev = curr;
        }
        return ret;
    }
    /// @brief f(x) = c
    /// @tparam T Type of number
    /// @param c Constant value
    /// @param inSet Set of number values we allow as input
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateConstFunction(T c, std::vector<T> inSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        return GenerateFunction<T>(ConstFunction(T, c), inSet, { c, }, inAxis, realAxis, imaginaryAxis);
    }
    /// @brief f(x) = x
    /// @tparam T Type of number
    /// @param inSet Set of number values we allow as input
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateIdentityFunction(std::vector<T> inSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        return GenerateFunction<T>(IdentityFunction(T), inSet, inSet, inAxis, realAxis, imaginaryAxis);
    }
    /// @brief f(0) = 0 and f(x) = x / |x|
    /// @tparam T Type of number
    /// @param inSet Set of number values we allow as input
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateSignumFunction(std::vector<T> inSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        return GenerateFunction<T>(SignumFunction(T), inSet, { -1, 0, 1, }, inAxis, realAxis, imaginaryAxis);
    }
    /// @brief f(x) = a_0 * x^0 + ... + a_n * x^n
    /// @tparam T Type of number
    /// @param a Array of numbers by which we multiply the power of x
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GeneratePolynomialFunction(std::vector<T> a, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        return GenerateFunction<T>(PolynomialFunction(T, a), inSet, outSet, inAxis, realAxis, imaginaryAxis);
    }
    /// @brief f(x) = p(x) / q(x)
    /// @tparam T Type of number
    /// @param p Function we are dividing
    /// @param q Function that is dividing
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateRationalFunction(std::function<std::complex<T>(T)> p, std::function<std::complex<T>(T)> q, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        return GenerateFunction<T>(RationalFunction(T, p, q), inSet, outSet, inAxis, realAxis, imaginaryAxis);
    }
    /// @brief f'(x) = (f(x + h) - f(x)) / h
    /// @tparam T Type of number
    /// @param f Function we want the derivative of
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @param imaginaryAxis Axis we are using for imaginary part of the output
    /// @return Result of function
    template<typename T>
    std::vector<Line<T>> GenerateDerivativeFunction(std::function<std::complex<T>(T)> f, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y, VectorAxis imaginaryAxis = VectorAxis::Z) {
        const T h = 1 / pointMultiplier;
        return GenerateFunction<T>(DerivativeFunction(T, f, h), inSet, outSet, inAxis, realAxis, imaginaryAxis);
    }
};

#endif