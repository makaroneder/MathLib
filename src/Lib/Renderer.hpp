#ifndef Renderer_H
#define Renderer_H
#include "Set.hpp"
#include "Line.hpp"
#include "Functions.hpp"
#include "Rectangle.hpp"
#include <stdint.h>
#include <iostream>

struct Renderer {
    /// @brief Current position
    Vector3<num_t> position;
    /// @brief Scale
    num_t pointMultiplier;
    /// @brief Creates a new renderer
    Renderer(void);
    /// @brief Destroys the renderer
    virtual ~Renderer(void);
    /// @brief Calculates width of the renderer window
    /// @return Width of the renderer window
    virtual size_t GetWidth(void) const = 0;
    /// @brief Calculates height of the renderer window
    /// @return Height of the renderer window
    virtual size_t GetHeight(void) const = 0;
    /// @brief Renders pixel
    /// @param p Position of pixel
    /// @param color Color of pixel
    /// @return Status
    virtual bool SetPixel(Vector3<num_t> p, uint32_t color) = 0;
    /// @brief Draws a line
    /// @param line Line to draw
    /// @param color Color of the line
    /// @return Status
    virtual bool DrawLine(Line<num_t> line, uint32_t color) = 0;
    /// @brief Renders filled rectangle
    /// @tparam T Type of number
    /// @param rect Rectangle to draw
    /// @param color Color of the rectangle
    /// @return Status
    template <typename T>
    bool FillRectangle(Rectangle<T> rect, uint32_t color) {
        T w = rect.width / 2;
        T h = rect.height / 2;
        const bool isFloat = IsFloat<T>();
        const T add = isFloat ? (1 / pointMultiplier) : 1;
        for (T y = -h; y <= h; y += add) {
            for (T x = -w; x <= w; x += add) {
                Vector3<T> pos = rect.position;
                GetVectorAxis(pos, VectorAxis::X) += x;
                GetVectorAxis(pos, VectorAxis::Y) += y;
                if (!SetPixel(ConvertMatrix<T, num_t>(pos), color)) return false;
            }
        }
        return true;
    }
    /// @brief Calculates start of the graph
    /// @tparam T Type of number
    /// @return Start of graph
    template <typename T>
    Vector3<T> GetStart(void) const {
        return CreateVector3<T>(-(GetWidth() / 2 / pointMultiplier), -(GetHeight() / 2 / pointMultiplier), 0);
    }
    /// @brief Calculates end of the graph
    /// @tparam T Type of number
    /// @return End of graph
    template <typename T>
    Vector3<T> GetEnd(void) const {
        return CreateVector3<T>(GetWidth() / 2 / pointMultiplier, GetHeight() / 2 / pointMultiplier, 0);
    }
    /// @brief Creates set of every pixel on the screen
    /// @tparam T Type of number
    /// @param axis Axis we are using
    /// @return Set of every pixel on the screen
    template <typename T>
    std::vector<T> CreateRealNumberSet(void) const {
        const bool isFloat = IsFloat<T>();
        const T div = isFloat ? 1 : pointMultiplier;
        const Vector3<T> startArr = GetStart<T>();
        const Vector3<T> endArr = GetEnd<T>();
        return CreateSet<T>(
            std::max<T>(GetVectorAxis(startArr, VectorAxis::X), GetVectorAxis(startArr, VectorAxis::Y)) * div,
            std::max<T>(GetVectorAxis(endArr, VectorAxis::X), GetVectorAxis(endArr, VectorAxis::Y)) * div,
            1 / (isFloat ? pointMultiplier : 1)
        );
    }
    /// @brief Draw x and y axis
    /// @param color Color of the axis
    /// @return Status
    bool DrawAxis(uint32_t color);
    /// @brief Draws function based on its values
    /// @tparam T Type of number
    /// @param values Values generated by function
    /// @param color Color of function
    /// @return Status
    template <typename T>
    bool DrawFunction(std::vector<Line<T>> values, uint32_t color) {
        const T div = IsFloat<T>() ? 1 : pointMultiplier;
        for (const Line<T>& val : values) {
            #ifdef FillGapsInFunctions
            if (!std::isnan(GetVectorAxis(val.start, VectorAxis::X)) && !DrawLine(ConvertLine<T, num_t>(Line<T>(val.start / div, val.end / div)), color)) return false;
            #else
            if (!SetPixel(ConvertMatrix<T, num_t>(val.end) / div, color)) return false;
            #endif
        }
        return true;
    }
    /// @brief y = f(x)
    /// @tparam T Type of number
    /// @param f Function that calculates x or y depending on the 'axis' parameter
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateFunction(std::function<std::vector<T>(T)> f, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        std::vector<Vector3<T>> prev;
        std::vector<Line<T>> ret;
        for (const T& i : inSet) {
            Vector3<T> curr = CreateVector3<T>(0, 0, 0);
            const std::vector<T> arr = f(i);
            if (prev.empty()) {
                prev.reserve(arr.size());
                for (T j = 0; j < arr.size(); j++) prev.push_back(CreateVector3<T>(NAN, NAN, NAN));
            }
            for (T j = 0; j < arr.size(); j++) {
                T tmp = arr.at(j);
                if (std::isnan(i) || std::isinf(i) || !IsInsideSet<T>(outSet, tmp, 1 / pointMultiplier)) {
                    prev.at(j) = CreateVector3<num_t>(NAN, NAN, NAN);
                    continue;
                }
                GetVectorAxis(curr, inAxis) = i;
                GetVectorAxis(curr, realAxis) = tmp;
                ret.push_back(Line<T>(prev.at(j) - position, curr - position));
                prev.at(j) = curr;
            }
        }
        return ret;
    }
    /// @brief y = f(x)
    /// @tparam T Type of number
    /// @param f Function that calculates x or y depending on the 'axis' parameter
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateFunction(std::function<T(T)> f, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        return GenerateFunction<T>([f](T x) {
            std::vector<T> ret = { f(x), };
            return ret;
        }, inSet, outSet, inAxis, realAxis);
    }
    /// @brief f(x) = c
    /// @tparam T Type of number
    /// @param c Constant value
    /// @param inSet Set of number values we allow as input
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateConstFunction(T c, std::vector<T> inSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        return GenerateFunction<T>(ConstFunction(T, c), inSet, { c, }, inAxis, realAxis);
    }
    /// @brief f(x) = x
    /// @tparam T Type of number
    /// @param inSet Set of number values we allow as input
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateIdentityFunction(std::vector<T> inSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        return GenerateFunction<T>(IdentityFunction(T), inSet, inSet, inAxis, realAxis);
    }
    /// @brief f(0) = 0 and f(x) = x / |x|
    /// @tparam T Type of number
    /// @param inSet Set of number values we allow as input
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateSignumFunction(std::vector<T> inSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        return GenerateFunction<T>(SignumFunction(T), inSet, { -1, 0, 1, }, inAxis, realAxis);
    }
    /// @brief f(x) = a_0 * x^0 + ... + a_n * x^n
    /// @tparam T Type of number
    /// @param a Array of numbers by which we multiply the power of x
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GeneratePolynomialFunction(std::vector<T> a, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        return GenerateFunction<T>(PolynomialFunction(T, a), inSet, outSet, inAxis, realAxis);
    }
    /// @brief f(x) = p(x) / q(x)
    /// @tparam T Type of number
    /// @param p Function we are dividing
    /// @param q Function that is dividing
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template <typename T>
    std::vector<Line<T>> GenerateRationalFunction(std::function<T(T)> p, std::function<T(T)> q, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        return GenerateFunction<T>(RationalFunction(T, p, q), inSet, outSet, inAxis, realAxis);
    }
    /// @brief f'(x) = (f(x + h) - f(x)) / h
    /// @tparam T Type of number
    /// @param f Function we want the derivative of
    /// @param inSet Set of number values we allow as input
    /// @param outSet Set of number values we allow as output
    /// @param inAxis Axis we are using for input values
    /// @param realAxis Axis we are using for real part of the output
    /// @return Result of function
    template<typename T>
    std::vector<Line<T>> GenerateDerivativeFunction(std::function<T(T)> f, std::vector<T> inSet, std::vector<T> outSet, VectorAxis inAxis = VectorAxis::X, VectorAxis realAxis = VectorAxis::Y) {
        const T h = 1 / pointMultiplier;
        return GenerateFunction<T>(DerivativeFunction(T, f, h), inSet, outSet, inAxis, realAxis);
    }
};

#endif